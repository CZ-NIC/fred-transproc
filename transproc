#!/usr/bin/env python
#
# vim: set ts=4 sw=4:

import sys, getopt, imaplib, commands, tempfile
import os, os.path, time, popen2, select, ConfigParser, fcntl
from email.FeedParser import FeedParser

verbose = False
configfile = "/usr/etc/fred/transproc.conf"

def usage():
	print '%s [-c config] [-H imaphost] [-p imappassword] [-u imapuser] [-v]' % sys.argv[0]

def debug(msg):
	global verbose
	if verbose:
		sys.stderr.write(msg + '\n')

def error(msg):
	sys.stderr.write(msg + '\n')

class Processor(object):
	'''Class representing a processor of transcript.'''
	def __init__(self, name):
		self.name     = name
		self.fromhead = None
		self.script   = None
		self.part     = 3


def makeNonBlocking(fd):
	"""
	Set non-blocking attribute on file.
	"""
	fl = fcntl.fcntl(fd, fcntl.F_GETFL)
	try:
		fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NDELAY)
	except AttributeError:
		fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.FNDELAY)

def runCommand(cmd, stdin):
	"""
	Run command in non-blocking manner.
	"""
	# run the command
	child = popen2.Popen3(cmd, True)
	if (stdin):
		child.tochild.write(stdin)
	child.tochild.close()
	outfile = child.fromchild 
	outfd = outfile.fileno()
	errfile = child.childerr
	errfd = errfile.fileno()
	makeNonBlocking(outfd)
	makeNonBlocking(errfd)
	outdata = errdata = ''
	outeof = erreof = 0
	for round in range(8):
		# wait for input at most 1 second
		ready = select.select([outfd,errfd], [], [], 1.0)
		if outfd in ready[0]:
			outchunk = outfile.read()
			if outchunk == '':
				outeof = 1
			else:
				outdata += outchunk
		if errfd in ready[0]:
			errchunk = errfile.read()
			if errchunk == '':
				erreof = 1
			else:
				errdata += errchunk
		if outeof and erreof: break
		time.sleep(0.3) # give a little time for buffers to fill

	child.fromchild.close()
	child.childerr.close()

	status = os.waitpid(child.pid, os.WNOHANG)

	if status[0] == 0:
		time.sleep(1)
		error("Child doesn't want to exit, TERM signal sent.")
		os.kill(child.pid, signal.SIGTERM)
		time.sleep(1.2) # time to exit
		status = os.waitpid(child.pid, os.WNOHANG)

		if status[0] == 0:
			error("Child doesn't want to die, KILL signal sent.")
			os.kill(child.pid, signal.SIGKILL)
			time.sleep(1.2) # time to exit
			status = os.waitpid(child.pid, os.WNOHANG)

	stat = 9 # by default assume error
	if outeof and erreof and (status[0] == child.pid) and os.WIFEXITED(status[1]):
		stat = os.WEXITSTATUS(status[1])
	return stat, outdata, errdata


def main():
	global verbose
	# parse command line options
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'c:h:p:u:v', [])
	except getopt.GetoptError:
		usage()
		sys.exit(2)
	# default values
	imaphost = None
	imappass = None
	imapuser = None
	nshost   = None
	# parameter values
	for o,a in opts:
		if o == '-c':
			configfile = a
		elif o == '-h':
			imaphost = a
		elif o == '-p':
			imappass = a
		elif o == '-u':
			imapuser = a
		elif o == '-v':
			verbose = True
		else:
			usage()
			sys.exit(2)
	# read configuration file
	config = ConfigParser.ConfigParser(
			{'imaphost':'localhost',
			 'imappass':'',
			 'imapuser':'transcripts',
			 'nshost':'localhost',
			 'fm_cmd':'filemanager_client',
			 'procdir':'/usr/libexec/transproc'})
	config.read(configfile)
	# set not zone specific configuration values
	if not imaphost:
		imaphost = config.get('general', 'imaphost')
	if not imappass:
		imappass = config.get('general', 'imappass')
	if not imapuser:
		imapuser = config.get('general', 'imapuser')
	if not nshost:
		nshost = config.get('general', 'nshost')
	fm_cmd = config.get('general', 'fm_cmd')
	procdir = config.get('general', 'procdir')
	if not config.has_option('general', 'backend'):
		error('Backend in configuration file must be set')
		sys.exit(2)
	backend = config.get('general', 'backend')
	# iterate over other sections in config
	processors = []
	for section in config.sections():
		if section == 'general':
			continue
		proc = Processor(section)
		if not config.has_option(section, 'fromhead'):
			error('fromhead directive must be set in %s section' % section)
			sys.exit(2)
		proc.fromhead = config.get(section, 'fromhead')
		if not config.has_option(section, 'processor'):
			error('processor directive must be set in %s section' % section)
			sys.exit(2)
		proc.script = os.path.join(procdir, config.get(section, 'processor'))
		if not os.path.isfile(proc.script):
			error('processor script "%s" does not exist' % proc.script)
			sys.exit(2)
		if config.has_option(section, 'part'):
			proc.part = config.getint(section, 'part')
		processors.append(proc)
	# end of configuration
	# action begins now
	server = imaplib.IMAP4(imaphost)
	debug('Connected to %s' % imaphost)
	server.login(imapuser, imappass)
	debug('Logged in as %s' % imapuser)
	server.select()
	error_seen = False
	for proc in processors:
		# get unseen messages from a bank
		r, data = server.search(None, '((UNSEEN) (FROM %s))' % proc.fromhead)
		msgids = data[0].split(' ')
		if not msgids[0]:
			debug('No new messages from %s in mailbox' % proc.name)
			continue
		# fetch new messages
		messages = {}
		for msgid in msgids:
			(r, data) = server.fetch(msgid, '(RFC822)')
			messages[msgid] = data[0][1]
		debug('%d new messages from %s' % (len(messages), proc.name))
		# process new messages by processor
		for msgid in messages:
			# separate attachment in which we are interested
			fp = FeedParser()
			fp.feed(messages[msgid])
			mail = fp.close()
			if proc.part > 1 and not mail.is_multipart():
				debug('%s: skipping message %d, it is not multipart' %
						(proc.name, msgid))
				continue
			# walk goes like this: whole message -> 1th part -> 2nd part
			i = 1
			for part in mail.walk():
				if i == proc.part: break
				i += 1
			if i != proc.part:
				debug('%s: skipping message %d, does not contain %d. part' %
						(proc.name, msgid, proc.part))
				sys.exit(2)
			filename = part.get_filename()
			mimetype = part.get_content_type()
			octets = part.get_payload(decode = True)
			debug('%s: processing message %s' % (proc.name, msgid))
			# run the processor:
			#    stdin:  raw email
			#    stdout: result of processing (XML)
			#    stderr: errors
			try:
				(status, outxml, err) = runCommand(proc.script, octets)
			except Exception, e:
				error('%s: execution of processor failed: %s' % (proc.name, e))
				# restore the UNSEEN flag - something in script failed
				# we will reprocess the email nexttime
				server.store(msgid, '-FLAGS', '\\Seen')
				error_seen = True
				continue
			if status == 2:
				# don't restore the UNSEEN flag - we want to avoid repetitive
				# processing nexttime
				debug('%s: message %d rejected: %s' % (proc.name, msgid, err))
				continue
			elif status != 0:
				if status != 1:
					error('%s: unknown return code (%d): %s' %
							(proc.name, status, err))
				else:
					error('%s: processing of message %s failed: %s' %
							(proc.name, msgid, err))
				# restore the UNSEEN flag - something in script failed
				# we will reprocess the email nexttime
				server.store(msgid, '-FLAGS', '\\Seen')
				error_seen = True
				continue
			debug('%s: message %s processed by processor' % (proc.name, msgid))
			# save the email via filemanager client
			cmd = '%s --label="%s" --mime="%s" --type=4 --nameservice="%s"'\
					% (fm_cmd, filename, mimetype, nshost)
			(status, output, err) = runCommand(cmd, octets)
			if status != 0:
				error('Error when executing command: %s\n%s' % (cmd, err))
				# restore the UNSEEN flag - something in script failed
				# we will reprocess the email nexttime
				server.store(msgid, '-FLAGS', '\\Seen')
				error_seen = True
				continue
			else:
				debug(cmd)
				debug('Filemanager\'s output:')
				debug(output)
			# process output XML and update database
			print '(status, output, err) = runCommand(backend, outxml)'
			print outxml
			if status != 0:
				error('Error when executing command: %s\n%s' % (backend, err))
				# restore the UNSEEN flag - something in script failed
				# we will reprocess the email nexttime
				server.store(msgid, '-FLAGS', '\\Seen')
				error_seen = True
				continue
			else:
				debug(backend)
				debug('Backend\'s output:')
				debug(output)
	server.close()
	server.logout()
	debug('Logged out')
	if error_seen:
		sys.exit(1)


if __name__ == '__main__':
	main()

